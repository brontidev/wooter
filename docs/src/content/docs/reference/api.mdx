---
title: API Reference
description: Complete API reference for wooter
---

# API Reference

Complete reference for all wooter APIs.

## `Wooter`

The main router class.

### Constructor

```ts
new Wooter<TData, TParentParams>(basePath?: TChemin<TParentParams>)
```

Creates a new router instance.

**Type Parameters:**
- `TData` - Middleware data type (default: `undefined`)
- `TParentParams` - Parent router parameters (default: `undefined`)

**Parameters:**
- `basePath` - Optional base path for this router (default: `c.chemin()`)

**Example:**
```ts
const wooter = new Wooter()
```

### Methods

#### `route(path, method, handler)`

Define a route with a single method.

```ts
route<TParams>(
    path: TChemin<TParams>,
    method: Methods | Methods[] | "*",
    handler: RouteHandler<TParams, TData>
): this
```

**Parameters:**
- `path` - Path pattern built with `c.chemin()`
- `method` - HTTP method(s) or `"*"` for all methods
- `handler` - Function to handle the request

**Example:**
```ts
wooter.route(c.chemin("user"), "GET", ({ resp }) => {
    resp(new Response("User"))
})

wooter.route(c.chemin("user"), ["GET", "HEAD"], ({ resp }) => {
    resp(new Response("User"))
})
```

#### `route(path, handlers)`

Define multiple methods for one path.

```ts
route<TParams>(
    path: TChemin<TParams>,
    handlers: MethodDefinitions<TParams, TData>
): this
```

**Parameters:**
- `path` - Path pattern built with `c.chemin()`
- `handlers` - Object mapping methods to handlers

**Example:**
```ts
wooter.route(c.chemin("user"), {
    GET({ resp }) {
        resp(Response.json({ action: "read" }))
    },
    POST({ resp }) {
        resp(Response.json({ action: "create" }))
    }
})
```

#### `use(handler)`

Apply middleware to the router.

```ts
use<TNextData>(
    handler: MiddlewareHandler<Params, TData, TNextData>
): Wooter<TData & TNextData, TParentParams>
```

**Parameters:**
- `handler` - Middleware function

**Returns:** New router instance with updated data types

**Example:**
```ts
const authedWooter = wooter.use(authMiddleware)
```

#### `router(basePath)`

Create a nested router.

```ts
router<TParams>(
    basePath: TChemin<TParams>
): Wooter<TData, TParams & TParentParams>
```

**Parameters:**
- `basePath` - Base path for the nested router

**Returns:** New router instance with combined parameters

**Example:**
```ts
const api = wooter.router(c.chemin("api"))
api.route(c.chemin("users"), "GET", ({ resp }) => {
    // Matches /api/users
    resp(Response.json({ users: [] }))
})
```

#### `notFound(handler)`

Set custom 404 handler.

```ts
notFound(handler: RouteHandler<{}>): this
```

**Parameters:**
- `handler` - Handler for unmatched routes

**Example:**
```ts
wooter.notFound(({ resp, request, url }) => {
    resp(new Response(`Not found: ${url.pathname}`, { status: 404 }))
})
```

#### `fetch(request)`

Handle an incoming request.

```ts
fetch(request: Request): Promise<Response>
```

**Parameters:**
- `request` - The incoming Request

**Returns:** Promise resolving to Response

**Example:**
```ts
Deno.serve(wooter.fetch)
```

---

## `RouteContext`

Context object passed to route handlers.

### Properties

#### `request: Request`
The incoming HTTP request.

#### `url: URL`
Parsed URL from the request.

#### `params: TypedMap<TParams>`
Route parameters extracted from the path.

**Methods:**
- `params.get(name)` - Get parameter value (type-safe)

#### `data: TData`
Data injected by middleware.

### Methods

#### `resp(response: Response): Response`

Send the response. **Must be called exactly once.**

**Parameters:**
- `response` - The Response to send

**Returns:** The same response

**Throws:**
- `HandlerRespondedTwiceError` if called multiple times

**Example:**
```ts
wooter.route(c.chemin(), "GET", ({ resp }) => {
    resp(new Response("Hello"))
})
```

#### `ok(): void`

Mark the handler as complete. Advanced usage only.

**Example:**
```ts
wooter.route(c.chemin(), "GET", async ({ resp, ok }) => {
    resp(new Response("OK"))
    await cleanup()
    ok()
})
```

---

## `MiddlewareContext`

Context object passed to middleware handlers. Extends `RouteContext`.

### Additional Methods

#### `next(data, request?): Promise<Option<Response>>`

Run the next handler and wait for it to respond.

**Parameters:**
- `data` - Data to pass to next handler
- `request` - Optional modified request

**Returns:** `Promise<Some(Response)>` if handler responded, `Promise<None>` if error

**Example:**
```ts
wooter.use(async ({ next, resp }) => {
    const responseOption = await next({ userId: 123 })
    responseOption.inspect((r) => resp(r))
})
```

#### `wait(): Promise<Result<null, unknown>>`

Wait for the handler to completely finish executing. **Must be called after `next()`.**

**Returns:** `Ok(null)` if successful, `Err(error)` if handler threw

**Throws:**
- `MiddlewareCalledWaitBeforeNextError` if called before `next()`

**Example:**
```ts
wooter.use(async ({ next, wait, resp }) => {
    const response = await next({})
    response.inspect((r) => resp(r))
    
    const result = await wait()
    result.match(
        () => console.log("Success"),
        (err) => console.error("Error:", err)
    )
})
```

#### `relay(data, request?): Promise<Option<Response>>`

Run next handler and immediately call `resp()` with the response.

Shorthand for: `(await next(data, request)).map(r => resp(r))`

**Parameters:**
- `data` - Data to pass to next handler
- `request` - Optional modified request

**Returns:** Response option

**Example:**
```ts
wooter.use(async ({ relay }) => {
    await relay({ timestamp: Date.now() })
})
```

#### `expectResponse(data, request?): Promise<Response>`

Run next handler and throw if it errors before responding.

**Parameters:**
- `data` - Data to pass to next handler
- `request` - Optional modified request

**Returns:** Response (guaranteed)

**Throws:** Error from handler if it failed before responding

**Example:**
```ts
wooter.use(async ({ expectResponse, resp }) => {
    const response = await expectResponse({})
    
    // Modify response
    const headers = new Headers(response.headers)
    headers.set("X-Custom", "value")
    
    resp(new Response(response.body, { ...response, headers }))
})
```

#### `expectAndRespond(data, request?): Promise<Response>`

Run handler, get response, and call `resp()` with it.

Shorthand for: `resp(await expectResponse(data, request))`

**Parameters:**
- `data` - Data to pass to next handler
- `request` - Optional modified request

**Returns:** Response (already sent via `resp()`)

**Example:**
```ts
wooter.use(async ({ expectAndRespond }) => {
    const response = await expectAndRespond({ data: "value" })
    // Response already sent
    await logResponse(response)
})
```

---

## Types

### `RouteHandler<TParams, TData>`

```ts
type RouteHandler<TParams, TData> = (
    ctx: RouteContext<TParams, TData>
) => Promise<unknown> | unknown
```

Route handler function.

### `MiddlewareHandler<TParams, TData, TNextData>`

```ts
type MiddlewareHandler<TParams, TData, TNextData> = (
    ctx: MiddlewareContext<TParams, TData, TNextData>
) => Promise<unknown> | unknown
```

Middleware handler function.

### `Methods`

```ts
type Methods = 
    | "GET"
    | "POST"
    | "PUT"
    | "PATCH"
    | "DELETE"
    | "HEAD"
    | "OPTIONS"
```

Standard HTTP methods.

### `Params`

```ts
type Params = Record<string, string | number | string[]>
```

Route parameters object.

### `Data`

```ts
type Data = Record<string, unknown>
```

Middleware data object.

---

## Utility Functions

### `middleware(handler)`

Helper for creating typed middleware.

```ts
function middleware<TNextData, TData, TParams>(
    handler: MiddlewareHandler<TParams, TData, TNextData>
): MiddlewareHandler<TParams, TData, TNextData>
```

**Example:**
```ts
import { middleware } from "@bronti/wooter/use"

const auth = middleware<{ user: User }>(async ({ expectAndRespond }) => {
    const user = await authenticate()
    await expectAndRespond({ user })
})
```

### `use(middleware, handler)`

Apply middleware to a single route handler.

```ts
function use<NextData, BaseData, TParams>(
    middleware: MiddlewareHandler<TParams, BaseData, NextData>,
    handler: RouteHandler<TParams, BaseData & NextData>
): RouteHandler<TParams, BaseData>
```

**Example:**
```ts
import { use } from "@bronti/wooter/use"

wooter.route(
    c.chemin("admin"),
    "GET",
    use(adminAuth, ({ resp, data }) => {
        resp(Response.json(data.admin))
    })
)
```

### `makeError(status, message)`

Create an error response.

```ts
function makeError(status: number, message: string): Response
```

**Example:**
```ts
import { makeError } from "@bronti/wooter"

resp(makeError(404, "Not found"))
```

### `makeRedirect(url, options)`

Create a redirect response.

```ts
function makeRedirect(
    url: string,
    options?: { status?: 301 | 302 | 303 | 307 | 308 }
): Response
```

**Example:**
```ts
import { makeRedirect } from "@bronti/wooter"

resp(makeRedirect("/new-path", { status: 301 }))
```

---

## Chemin (Path Builder)

### `c.chemin(...segments)`

Build a path pattern.

```ts
c.chemin("api", "users")           // /api/users
c.chemin("user", c.pNumber("id"))  // /user/:id
c.chemin()                          // / (root)
```

### Parameter Matchers

#### `c.pString(name)`
Match any string parameter.

```ts
c.chemin("posts", c.pString("slug"))  // /posts/:slug
```

#### `c.pNumber(name)`
Match and parse number parameter.

```ts
c.chemin("user", c.pNumber("id"))     // /user/:id
```

#### `c.pRest(name)`
Match all remaining path segments.

```ts
c.chemin("files", c.pRest("path"))    // /files/*
```

---

## Error Classes

### `HandlerDidntRespondError`

Thrown when a handler exits without calling `resp()`.

```ts
class HandlerDidntRespondError extends WooterError
```

### `HandlerRespondedTwiceError`

Thrown when `resp()` is called multiple times.

```ts
class HandlerRespondedTwiceError extends WooterError
```

### `MiddlewareHandlerDidntCallUpError`

Thrown when middleware exits without calling a control flow method.

```ts
class MiddlewareHandlerDidntCallUpError extends WooterError
```

### `MiddlewareCalledWaitBeforeNextError`

Thrown when `wait()` is called before `next()`.

```ts
class MiddlewareCalledWaitBeforeNextError extends WooterError
```

---

## Option Type

Wooter uses an Option type for values that may or may not exist.

### `Option<T>`

```ts
type Option<T> = Some<T> | None
```

### Methods

#### `isSome(): boolean`
Check if option contains a value.

#### `isNone(): boolean`
Check if option is empty.

#### `unwrap(): T`
Get value or throw.

#### `unwrapOr(defaultValue: T): T`
Get value or default.

#### `map<U>(fn: (value: T) => U): Option<U>`
Transform the value if present.

#### `inspect(fn: (value: T) => void): void`
Run function on value if present.

#### `match<U>(onSome: (value: T) => U, onNone: () => U): U`
Pattern match on the option.

**Example:**
```ts
const responseOption = await next({})

responseOption.match(
    (response) => resp(response),
    () => console.log("No response")
)
```

---

## Result Type

Wooter uses a Result type for operations that may fail.

### `Result<T, E>`

```ts
type Result<T, E> = Ok<T> | Err<E>
```

### Methods

#### `isOk(): boolean`
Check if result is Ok.

#### `isErr(): boolean`
Check if result is Err.

#### `unwrap(): T`
Get value or throw.

#### `unwrapErr(): E`
Get error or throw.

#### `match<U>(onOk: (value: T) => U, onErr: (error: E) => U): U`
Pattern match on the result.

#### `inspectErr(fn: (error: E) => void): void`
Run function on error if present.

**Example:**
```ts
const result = await wait()

result.match(
    () => console.log("Success"),
    (error) => console.error("Failed:", error)
)
```
